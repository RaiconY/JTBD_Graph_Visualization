<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jobs To Be Done - 3D Graph</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            cursor: grab;
            background: #0a0a0a;
        }
        
        body:active {
            cursor: grabbing;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            user-select: none;
            z-index: 100;
            pointer-events: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            user-select: none;
            z-index: 100;
            pointer-events: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }
        
        #startButton {
            padding: 15px 40px;
            font-size: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }
        
        #startButton:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .description {
            max-width: 600px;
            text-align: center;
            padding: 0 20px;
            line-height: 1.6;
            opacity: 0.95;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>ü´ß Jobs To Be Done - –ì—Ä–∞—Ñ —Ä–∞–±–æ—Ç ü´ß</h1>
        <div class="description">
            <p>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ JTBD —á–µ—Ä–µ–∑ —Å–≤—è–∑–∞–Ω–Ω—ã–µ –ø—É–∑—ã—Ä–∏</p>
            <p style="font-size: 14px; opacity: 0.8;">600+ —É–∑–ª–æ–≤, —Å–≤—è–∑–∏ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è</p>
        </div>
        <button id="startButton">–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç—å –≥—Ä–∞—Ñ</button>
        <p style="margin-top: 20px; opacity: 0.8; font-size: 14px;">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: WASD - –¥–≤–∏–∂–µ–Ω–∏–µ, –ú—ã—à—å (–∑–∞–∂–∞—Ç—å) - –æ—Å–º–æ—Ç—Ä</p>
    </div>
    
    <div id="info" style="display: none;">
        <div style="font-weight: bold; margin-bottom: 8px;">üìä Jobs To Be Done Graph</div>
        <div style="font-size: 12px; opacity: 0.8;">WASD - –î–≤–∏–∂–µ–Ω–∏–µ</div>
        <div style="font-size: 12px; opacity: 0.8;">–ú—ã—à—å (–∑–∞–∂–∞—Ç—å) - –û—Å–º–æ—Ç—Ä</div>
        <div style="font-size: 12px; opacity: 0.8;">Shift - –£—Å–∫–æ—Ä–µ–Ω–∏–µ</div>
        <div style="font-size: 12px; opacity: 0.8;">Space/Ctrl - –í–≤–µ—Ä—Ö/–í–Ω–∏–∑</div>
    </div>
    
    <div id="stats" style="display: none;">
        <div style="font-weight: bold; margin-bottom: 8px;">üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</div>
        <div id="nodeCount" style="font-size: 12px;">–£–∑–ª–æ–≤: 0</div>
        <div id="connectionCount" style="font-size: 12px;">–°–≤—è–∑–µ–π: 0</div>
        <div id="avgConnections" style="font-size: 12px;">–°—Ä–µ–¥–Ω–µ–µ —Å–≤—è–∑–µ–π: 0</div>
        <div id="dimensionStats" style="font-size: 12px; margin-top: 8px; opacity: 0.8; line-height: 1.4;"></div>
    </div>
    
    <div id="crosshair" style="display: none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let bubbles = [];
        let connections = [];
        let connectionLines = [];
        let bubbleGlowTexture;
        const dimensions = [];
        const dimensionConfigs = [
            {
                name: '–ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Ä—ã–Ω–∫–∞',
                color: 0x4a90e2,
                size: new THREE.Vector3(260, 180, 260),
                center: new THREE.Vector3(-260, 0, -180)
            },
            {
                name: '–¶–µ–Ω–Ω–æ—Å—Ç—å –ø—Ä–æ–¥—É–∫—Ç–∞',
                color: 0xff6ec7,
                size: new THREE.Vector3(260, 180, 260),
                center: new THREE.Vector3(260, 0, -180)
            },
            {
                name: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –æ–ø—ã—Ç',
                color: 0x7ed321,
                size: new THREE.Vector3(260, 180, 260),
                center: new THREE.Vector3(-260, 0, 220)
            },
            {
                name: '–û–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã',
                color: 0xffb347,
                size: new THREE.Vector3(260, 180, 260),
                center: new THREE.Vector3(260, 0, 220)
            }
        ];
        const tempVector = new THREE.Vector3();
        const tempVector2 = new THREE.Vector3();
        const tempMin = new THREE.Vector3();
        const tempMax = new THREE.Vector3();
        const tempHSL = { h: 0, s: 0, l: 0 };
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false;
        let isShiftPressed = false;

        const localDensityConfig = {
            cellSize: 60,
            neighborRadius: 80,
            maxNeighbors: 12,
            forceStrength: 0.015,
            damping: 0.9,
            maxDriftSpeed: 0.4
        };

        const localDensityState = {
            grid: new Map()
        };
        
        let velocity = new THREE.Vector3();
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        
        // –ì—Ä—É–ø–ø–∞ –¥–ª—è –∫–∞–º–µ—Ä—ã
        let yawObject;
        let pitchObject;
        
        const startButton = document.getElementById('startButton');
        const startScreen = document.getElementById('startScreen');
        const info = document.getElementById('info');
        const stats = document.getElementById('stats');
        const crosshair = document.getElementById('crosshair');
        const dimensionStatsElement = document.getElementById('dimensionStats');
        
        startButton.addEventListener('click', () => {
            startScreen.style.display = 'none';
            info.style.display = 'block';
            stats.style.display = 'block';
            crosshair.style.display = 'block';
            init();
            animate();
        });
        
        function init() {
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x050510, 100, 800);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –≤—Ä–∞—â–µ–Ω–∏—è
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            yawObject = new THREE.Object3D();
            yawObject.position.set(0, 50, 150);
            
            pitchObject = new THREE.Object3D();
            pitchObject.add(camera);
            
            yawObject.add(pitchObject);
            scene.add(yawObject);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x0a0a0a, 1);
            document.body.appendChild(renderer.domElement);
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(100, 200, 100);
            scene.add(directionalLight);
            
            // –¶–≤–µ—Ç–Ω—ã–µ —Ç–æ—á–µ—á–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞ –¥–ª—è –∞—Ç–º–æ—Å—Ñ–µ—Ä—ã
            const pointLight1 = new THREE.PointLight(0x00ffff, 0.2, 300);
            pointLight1.position.set(-100, 50, -100);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xff00ff, 0.2, 300);
            pointLight2.position.set(100, 50, 100);
            scene.add(pointLight2);
            
            const pointLight3 = new THREE.PointLight(0xffff00, 0.2, 300);
            pointLight3.position.set(0, 100, 0);
            scene.add(pointLight3);

            // –ú–Ω–æ–≥–æ–º–µ—Ä–Ω—ã–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
            createDimensions();

            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—É–∑—ã—Ä–µ–π –∏ —Å–≤—è–∑–µ–π
            createBubblesAndConnections();
            
            // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–≤—è–∑–µ–π
            createConnectionLines();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            updateStats();
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è –∞—Ç–º–æ—Å—Ñ–µ—Ä—ã
            createParticles();
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        function createDimensions() {
            if (dimensions.length > 0) {
                dimensions.forEach(dimension => {
                    if (dimension.group) {
                        scene.remove(dimension.group);
                    }
                });
                dimensions.length = 0;
            }

            dimensionConfigs.forEach((config, index) => {
                const group = new THREE.Group();
                group.position.copy(config.center);

                const fillGeometry = new THREE.BoxGeometry(config.size.x, config.size.y, config.size.z);
                const fillMaterial = new THREE.MeshBasicMaterial({
                    color: config.color,
                    transparent: true,
                    opacity: 0.05,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: false,
                    side: THREE.DoubleSide
                });
                const fill = new THREE.Mesh(fillGeometry, fillMaterial);
                fill.renderOrder = -2;
                group.add(fill);

                const outlineGeometry = new THREE.EdgesGeometry(fillGeometry);
                const outlineMaterial = new THREE.LineBasicMaterial({
                    color: config.color,
                    transparent: true,
                    opacity: 0.4,
                    depthTest: false
                });
                const outline = new THREE.LineSegments(outlineGeometry, outlineMaterial);
                outline.renderOrder = -1;
                group.add(outline);

                const floorGeometry = new THREE.PlaneGeometry(config.size.x * 0.96, config.size.z * 0.96, 1, 1);
                const floorMaterial = new THREE.MeshBasicMaterial({
                    color: config.color,
                    transparent: true,
                    opacity: 0.08,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    side: THREE.DoubleSide,
                    depthTest: false
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -config.size.y / 2 + 2;
                floor.renderOrder = -2;
                group.add(floor);

                const label = createDimensionLabelSprite(config.name, config.color);
                label.position.set(0, config.size.y * 0.6, 0);
                group.add(label);

                const halfSize = config.size.clone().multiplyScalar(0.5);
                const boundsMin = config.center.clone().sub(halfSize);
                const boundsMax = config.center.clone().add(halfSize);

                const dimension = {
                    index,
                    name: config.name,
                    color: new THREE.Color(config.color),
                    size: config.size.clone(),
                    center: config.center.clone(),
                    boundsMin,
                    boundsMax,
                    group,
                    fill,
                    outline,
                    floor,
                    label,
                    labelBaseScale: { x: label.scale.x, y: label.scale.y },
                    bubbleIndices: [],
                    clusterCenters: [],
                    pulseOffset: Math.random() * Math.PI * 2
                };

                const clusterCount = 5;
                for (let c = 0; c < clusterCount; c++) {
                    dimension.clusterCenters.push(samplePointInsideDimension(dimension, new THREE.Vector3(), 0.35));
                }

                dimensions.push(dimension);
                scene.add(group);
            });
        }

        function createDimensionLabelSprite(text, colorHex) {
            const canvas = document.createElement('canvas');
            const size = 256;
            canvas.width = canvas.height = size;
            const context = canvas.getContext('2d');
            context.clearRect(0, 0, size, size);

            const color = new THREE.Color(colorHex);
            const strokeStyle = color.getStyle();

            const padding = 32;
            const radius = 48;

            context.fillStyle = 'rgba(10, 10, 25, 0.75)';
            context.strokeStyle = strokeStyle;
            context.lineWidth = 6;
            context.beginPath();
            context.moveTo(padding + radius, padding);
            context.lineTo(size - padding - radius, padding);
            context.quadraticCurveTo(size - padding, padding, size - padding, padding + radius);
            context.lineTo(size - padding, size - padding - radius);
            context.quadraticCurveTo(size - padding, size - padding, size - padding - radius, size - padding);
            context.lineTo(padding + radius, size - padding);
            context.quadraticCurveTo(padding, size - padding, padding, size - padding - radius);
            context.lineTo(padding, padding + radius);
            context.quadraticCurveTo(padding, padding, padding + radius, padding);
            context.closePath();
            context.fill();
            context.stroke();

            context.font = 'bold 44px "Arial"';
            context.fillStyle = 'rgba(255, 255, 255, 0.92)';
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            words.forEach(word => {
                const testLine = currentLine ? `${currentLine} ${word}` : word;
                const metrics = context.measureText(testLine);
                if (metrics.width > size - padding * 3 && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            if (currentLine) {
                lines.push(currentLine);
            }

            const lineHeight = 50;
            const startY = size / 2 - ((lines.length - 1) * lineHeight) / 2;
            lines.forEach((line, index) => {
                context.fillText(line, size / 2, startY + index * lineHeight);
            });

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(180, 80, 1);
            sprite.renderOrder = 1;
            return sprite;
        }

        function samplePointInsideDimension(dimension, target = new THREE.Vector3(), marginRatio = 0.2) {
            tempMin.copy(dimension.boundsMin);
            tempMax.copy(dimension.boundsMax);
            tempVector.copy(dimension.size).multiplyScalar(marginRatio);
            tempMin.add(tempVector);
            tempMax.sub(tempVector);

            target.set(
                THREE.MathUtils.lerp(tempMin.x, tempMax.x, Math.random()),
                THREE.MathUtils.lerp(tempMin.y, tempMax.y, Math.random()),
                THREE.MathUtils.lerp(tempMin.z, tempMax.z, Math.random())
            );
            return target;
        }

        function constrainPositionToDimensions(userData) {
            if (!userData.dimensionIndices || userData.dimensionIndices.length === 0) {
                return;
            }

            const indices = userData.dimensionIndices;
            tempMin.copy(dimensions[indices[0]].boundsMin);
            tempMax.copy(dimensions[indices[0]].boundsMax);
            tempVector.set(0, 0, 0);

            for (let i = 0; i < indices.length; i++) {
                const dimension = dimensions[indices[i]];
                if (!dimension) continue;
                if (i > 0) {
                    tempMin.min(dimension.boundsMin);
                    tempMax.max(dimension.boundsMax);
                }
                tempVector.add(dimension.center);
            }

            userData.originalPosition.x = THREE.MathUtils.clamp(userData.originalPosition.x, tempMin.x, tempMax.x);
            userData.originalPosition.y = THREE.MathUtils.clamp(userData.originalPosition.y, tempMin.y, tempMax.y);
            userData.originalPosition.z = THREE.MathUtils.clamp(userData.originalPosition.z, tempMin.z, tempMax.z);

            const attractionTarget = tempVector.divideScalar(indices.length);
            const attractionStrength = indices.length > 1 ? 0.035 : 0.02;
            userData.originalPosition.lerp(attractionTarget, attractionStrength);
        }

        function createBubblesAndConnections() {
            localDensityState.grid.clear();
            const bubbleCount = 600;

            if (bubbles.length > 0) {
                bubbles.forEach(bubble => {
                    if (bubble.userData && bubble.userData.forceGlow) {
                        scene.remove(bubble.userData.forceGlow);
                    }
                    scene.remove(bubble);
                });
            }

            bubbles = [];
            connections = [];
            connectionLines = [];

            if (!bubbleGlowTexture) {
                const glowSize = 256;
                const glowCanvas = document.createElement('canvas');
                glowCanvas.width = glowCanvas.height = glowSize;
                const glowContext = glowCanvas.getContext('2d');

                const center = glowSize / 2;
                const gradient = glowContext.createRadialGradient(center, center, 0, center, center, center);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                glowContext.clearRect(0, 0, glowSize, glowSize);
                glowContext.fillStyle = gradient;
                glowContext.fillRect(0, 0, glowSize, glowSize);

                bubbleGlowTexture = new THREE.CanvasTexture(glowCanvas);
                bubbleGlowTexture.needsUpdate = true;
            }

            dimensions.forEach(dimension => {
                dimension.bubbleIndices.length = 0;
            });

            const dimensionAssignment = [];
            if (dimensions.length > 0) {
                const basePerDimension = Math.floor(bubbleCount / dimensions.length);
                for (let d = 0; d < dimensions.length; d++) {
                    for (let n = 0; n < basePerDimension; n++) {
                        dimensionAssignment.push(d);
                    }
                }
                while (dimensionAssignment.length < bubbleCount) {
                    dimensionAssignment.push(Math.floor(Math.random() * dimensions.length));
                }
                for (let i = dimensionAssignment.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    const temp = dimensionAssignment[i];
                    dimensionAssignment[i] = dimensionAssignment[j];
                    dimensionAssignment[j] = temp;
                }
            }

            for (let i = 0; i < bubbleCount; i++) {
                const baseRadius = Math.random() * 0.8 + 0.5;
                const geometry = new THREE.SphereGeometry(baseRadius, 16, 8);

                const primaryIndex = dimensionAssignment.length > 0 ? dimensionAssignment[i % dimensionAssignment.length] : 0;
                const primaryDimension = dimensions[primaryIndex];

                let hue;
                let saturation;
                let lightness;
                let baseBrightness = 0.22;
                if (primaryDimension) {
                    primaryDimension.color.getHSL(tempHSL);
                    hue = THREE.MathUtils.euclideanModulo(tempHSL.h + (Math.random() - 0.5) * 0.12, 1);
                    saturation = THREE.MathUtils.clamp(tempHSL.s + (Math.random() - 0.5) * 0.25, 0.25, 1);
                    lightness = THREE.MathUtils.clamp(tempHSL.l + (Math.random() - 0.5) * 0.3, 0.25, 0.75);
                    baseBrightness = 0.22 + (lightness - tempHSL.l) * 0.3;
                } else {
                    hue = Math.random();
                    saturation = 0.65;
                    lightness = 0.5;
                }

                const bubbleColor = new THREE.Color().setHSL(hue, saturation, lightness);
                const emissiveColor = new THREE.Color().setHSL(hue, Math.min(1, saturation * 0.85), Math.min(1, lightness + 0.15));
                const glowColor = new THREE.Color().setHSL(hue, Math.min(1, saturation * 0.9), Math.min(1, lightness + 0.2));
                const forceGlowColor = new THREE.Color().setHSL(hue, 0.85, 0.75);

                const material = new THREE.MeshPhysicalMaterial({
                    color: bubbleColor,
                    metalness: 0.1,
                    roughness: 0.2,
                    transparent: true,
                    opacity: 0.7,
                    emissive: emissiveColor,
                    emissiveIntensity: baseBrightness,
                    side: THREE.DoubleSide
                });

                const bubble = new THREE.Mesh(geometry, material);

                const glowMaterial = new THREE.SpriteMaterial({
                    map: bubbleGlowTexture,
                    color: glowColor,
                    transparent: true,
                    opacity: 0.35,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: false
                });
                glowMaterial.needsUpdate = true;
                const glowSprite = new THREE.Sprite(glowMaterial);
                const baseGlowScale = baseRadius * 4;
                glowSprite.scale.set(baseGlowScale, baseGlowScale, 1);
                bubble.add(glowSprite);

                const forceGlowMaterial = new THREE.SpriteMaterial({
                    map: bubbleGlowTexture,
                    color: forceGlowColor,
                    transparent: true,
                    opacity: 0,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: false
                });
                const forceGlowSprite = new THREE.Sprite(forceGlowMaterial);
                const forceGlowBaseScale = baseGlowScale * 0.55;
                forceGlowSprite.scale.set(forceGlowBaseScale, forceGlowBaseScale, 1);
                forceGlowSprite.visible = false;
                scene.add(forceGlowSprite);

                const sizeCoefficient = 0.3 + Math.random() * 1.4;
                const brightnessCoefficient = 0.3 + Math.random() * 1.4;
                const baseGlowOpacity = glowMaterial.opacity;

                bubble.scale.setScalar(sizeCoefficient);
                bubble.material.emissiveIntensity = THREE.MathUtils.clamp(baseBrightness * brightnessCoefficient, 0.05, 3);
                glowMaterial.opacity = THREE.MathUtils.clamp(baseGlowOpacity * brightnessCoefficient, 0, 1);

                const assignedDimensions = [];
                const basePosition = new THREE.Vector3();

                if (primaryDimension) {
                    assignedDimensions.push(primaryIndex);

                    if (primaryDimension.clusterCenters.length > 0) {
                        const clusterCenter = primaryDimension.clusterCenters[Math.floor(Math.random() * primaryDimension.clusterCenters.length)];
                        basePosition.copy(clusterCenter);
                    } else {
                        samplePointInsideDimension(primaryDimension, basePosition, 0.25);
                    }

                    basePosition.x += (Math.random() - 0.5) * primaryDimension.size.x * 0.25;
                    basePosition.y += (Math.random() - 0.5) * primaryDimension.size.y * 0.2;
                    basePosition.z += (Math.random() - 0.5) * primaryDimension.size.z * 0.25;

                    if (dimensions.length > 1 && Math.random() < 0.18) {
                        let secondaryIndex = Math.floor(Math.random() * dimensions.length);
                        if (secondaryIndex === primaryIndex) {
                            secondaryIndex = (secondaryIndex + 1) % dimensions.length;
                        }
                        const secondaryDimension = dimensions[secondaryIndex];
                        if (secondaryDimension) {
                            assignedDimensions.push(secondaryIndex);
                            tempVector.copy(primaryDimension.center);
                            tempVector2.copy(secondaryDimension.center);
                            const blendFactor = Math.random() * 0.6 + 0.2;
                            basePosition.lerpVectors(tempVector, tempVector2, blendFactor);

                            const rangeX = Math.min(primaryDimension.size.x, secondaryDimension.size.x) * 0.25;
                            const rangeY = Math.min(primaryDimension.size.y, secondaryDimension.size.y) * 0.3;
                            const rangeZ = Math.min(primaryDimension.size.z, secondaryDimension.size.z) * 0.25;
                            basePosition.x += (Math.random() - 0.5) * rangeX;
                            basePosition.y += (Math.random() - 0.5) * rangeY;
                            basePosition.z += (Math.random() - 0.5) * rangeZ;
                        }
                    }
                } else {
                    basePosition.set(
                        (Math.random() - 0.5) * 400,
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 400
                    );
                }

                bubble.position.copy(basePosition);

                bubble.castShadow = true;
                bubble.receiveShadow = true;

                bubble.userData = {
                    id: i,
                    floatSpeed: Math.random() * 0.002 + 0.001,
                    rotationSpeed: (Math.random() - 0.5) * 0.002,
                    originalPosition: bubble.position.clone(),
                    phase: Math.random() * Math.PI * 2,
                    connections: [],
                    baseRadius: baseRadius,
                    baseBrightness: baseBrightness,
                    sizeCoefficient: sizeCoefficient,
                    brightnessCoefficient: brightnessCoefficient,
                    glow: glowSprite,
                    baseGlowScale: baseGlowScale,
                    baseGlowOpacity: baseGlowOpacity,
                    driftVelocity: new THREE.Vector3(),
                    densityAccumulator: new THREE.Vector3(),
                    pendingForce: new THREE.Vector3(),
                    neighborIndices: [],
                    localDensity: 0,
                    forceGlow: forceGlowSprite,
                    forceGlowBaseScale,
                    forceGlowOffset: new THREE.Vector3(),
                    forceGlowIntensity: 0,
                    forceGlowBaseOpacity: 0,
                    forceGlowTargetScale: forceGlowBaseScale,
                    dimensionIndices: assignedDimensions
                };

                constrainPositionToDimensions(bubble.userData);
                bubble.position.copy(bubble.userData.originalPosition);

                forceGlowSprite.position.copy(bubble.position);

                scene.add(bubble);
                bubbles.push(bubble);

                const bubbleIndex = bubbles.length - 1;
                assignedDimensions.forEach(dimensionIndex => {
                    const dimension = dimensions[dimensionIndex];
                    if (dimension) {
                        dimension.bubbleIndices.push(bubbleIndex);
                    }
                });
            }
            
            // –°–æ–∑–¥–∞–µ–º —Å–≤—è–∑–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –∏ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç–∏ –∫ –∏–∑–º–µ—Ä–µ–Ω–∏—è–º
            const maxIntraDimensionDistance = 55;
            const maxCrossDimensionDistance = 80;
            const minConnectionDistance = 5; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ

            for (let i = 0; i < bubbles.length; i++) {
                for (let j = i + 1; j < bubbles.length; j++) {
                    const distance = bubbles[i].position.distanceTo(bubbles[j].position);

                    const dimsA = bubbles[i].userData.dimensionIndices || [];
                    const dimsB = bubbles[j].userData.dimensionIndices || [];
                    let sharedDimension = false;
                    for (let d = 0; d < dimsA.length && !sharedDimension; d++) {
                        if (dimsB.includes(dimsA[d])) {
                            sharedDimension = true;
                        }
                    }

                    const effectiveMaxDistance = sharedDimension ? maxIntraDimensionDistance : maxCrossDimensionDistance;

                    if (distance < effectiveMaxDistance && distance > minConnectionDistance) {
                        const normalizedDistance = 1 - (distance / effectiveMaxDistance);
                        const probabilityStrength = sharedDimension ? normalizedDistance ** 2 : normalizedDistance ** 1.5 * 0.35;

                        if (Math.random() < probabilityStrength) {
                            const strength = normalizedDistance * (sharedDimension ? 1 : 0.75);

                            connections.push({
                                from: i,
                                to: j,
                                distance: distance,
                                strength: strength,
                                sharedDimension
                            });

                            bubbles[i].userData.connections.push(j);
                            bubbles[j].userData.connections.push(i);
                        }
                    }
                }
            }
        }
        
        function createConnectionLines() {
            // –ì—Ä—É–ø–ø–∞ –¥–ª—è –≤—Å–µ—Ö –ª–∏–Ω–∏–π
            const linesGroup = new THREE.Group();
            
            connections.forEach(connection => {
                const points = [];
                points.push(bubbles[connection.from].position);
                points.push(bubbles[connection.to].position);
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // –ú–∞—Ç–µ—Ä–∏–∞–ª —Å —Ç–æ–ª—â–∏–Ω–æ–π –∏ —Å–≤–µ—á–µ–Ω–∏–µ–º –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∏–ª—ã —Å–≤—è–∑–∏
                const baseHue = connection.sharedDimension
                    ? 0.5 - connection.strength * 0.25
                    : 0.08 + (1 - connection.strength) * 0.05;
                const baseSaturation = connection.sharedDimension ? 0.8 : 0.95;
                const baseLightness = connection.sharedDimension
                    ? 0.5 + connection.strength * 0.25
                    : 0.6 + connection.strength * 0.2;

                const material = new THREE.LineBasicMaterial({
                    color: new THREE.Color().setHSL(baseHue, baseSaturation, Math.min(1, baseLightness)),
                    opacity: connection.strength * (connection.sharedDimension ? 0.6 : 0.45) + 0.1,
                    transparent: true,
                    linewidth: connection.strength * (connection.sharedDimension ? 3 : 2.2) + 1,
                    blending: THREE.AdditiveBlending
                });
                
                const line = new THREE.Line(geometry, material);
                
                // –î–ª—è –æ—á–µ–Ω—å —Å–∏–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π –¥–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—á–µ–Ω–∏–µ
                if (connection.strength > 0.7) {
                    const glowMaterial = new THREE.LineBasicMaterial({
                        color: new THREE.Color().setHSL(
                            connection.sharedDimension ? 0.5 - connection.strength * 0.2 : 0.04,
                            1,
                            0.7 + (connection.sharedDimension ? 0 : 0.1)
                        ),
                        opacity: connection.strength * (connection.sharedDimension ? 0.2 : 0.15),
                        transparent: true,
                        linewidth: connection.strength * 6 + 2,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const glowLine = new THREE.Line(geometry.clone(), glowMaterial);
                    glowLine.userData = {
                        from: connection.from,
                        to: connection.to,
                        strength: connection.strength,
                        isGlow: true,
                        sharedDimension: connection.sharedDimension
                    };
                    
                    linesGroup.add(glowLine);
                    connectionLines.push(glowLine);
                }
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏
                line.userData = {
                    from: connection.from,
                    to: connection.to,
                    strength: connection.strength,
                    distance: connection.distance,
                    sharedDimension: connection.sharedDimension
                };
                
                linesGroup.add(line);
                connectionLines.push(line);
            });
            
            scene.add(linesGroup);
        }
        
        function createParticles() {
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = 2000;
            const positions = new Float32Array(particlesCount * 3);
            const colors = new Float32Array(particlesCount * 3);
            
            for (let i = 0; i < particlesCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 600;
                positions[i + 1] = (Math.random() - 0.5) * 400;
                positions[i + 2] = (Math.random() - 0.5) * 600;
                
                const color = new THREE.Color().setHSL(Math.random(), 0.3, 0.3);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({ 
                size: 0.2,
                opacity: 0.4,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);
        }
        
        function updateStats() {
            document.getElementById('nodeCount').textContent = `–£–∑–ª–æ–≤: ${bubbles.length}`;
            document.getElementById('connectionCount').textContent = `–°–≤—è–∑–µ–π: ${connections.length}`;
            
            let totalConnections = 0;
            bubbles.forEach(bubble => {
                totalConnections += bubble.userData.connections.length;
            });
            const avgConnections = (totalConnections / bubbles.length).toFixed(1);
            document.getElementById('avgConnections').textContent = `–°—Ä–µ–¥–Ω–µ–µ —Å–≤—è–∑–µ–π: ${avgConnections}`;

            if (dimensionStatsElement) {
                if (!dimensions.length) {
                    dimensionStatsElement.textContent = '';
                } else {
                    const lines = dimensions.map(dimension => {
                        const colorStyle = dimension.color.getStyle();
                        return `<span style="color: ${colorStyle};">${dimension.name}: ${dimension.bubbleIndices.length}</span>`;
                    });
                    const bridgingCount = bubbles.reduce((total, bubble) => {
                        const dims = bubble.userData.dimensionIndices || [];
                        return total + (dims.length > 1 ? 1 : 0);
                    }, 0);
                    lines.push(`<span style="color: rgba(255, 255, 255, 0.75);">–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è: ${bridgingCount}</span>`);
                    dimensionStatsElement.innerHTML = lines.join('<br>');
                }
            }
        }
        
        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseUp(event) {
            isMouseDown = false;
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            yawObject.rotation.y -= deltaX * 0.002;
            pitchObject.rotation.x -= deltaY * 0.002;
            
            pitchObject.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitchObject.rotation.x));
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onKeyDown(event) {
            switch(event.key.toLowerCase()) {
                case 'w':
                case '—Ü':
                    moveForward = true;
                    break;
                case 's':
                case '—ã':
                    moveBackward = true;
                    break;
                case 'a':
                case '—Ñ':
                    moveLeft = true;
                    break;
                case 'd':
                case '–≤':
                    moveRight = true;
                    break;
                case ' ':
                    moveUp = true;
                    event.preventDefault();
                    break;
                case 'control':
                    moveDown = true;
                    event.preventDefault();
                    break;
                case 'shift':
                    isShiftPressed = true;
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch(event.key.toLowerCase()) {
                case 'w':
                case '—Ü':
                    moveForward = false;
                    break;
                case 's':
                case '—ã':
                    moveBackward = false;
                    break;
                case 'a':
                case '—Ñ':
                    moveLeft = false;
                    break;
                case 'd':
                case '–≤':
                    moveRight = false;
                    break;
                case ' ':
                    moveUp = false;
                    break;
                case 'control':
                    moveDown = false;
                    break;
                case 'shift':
                    isShiftPressed = false;
                    break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function rebuildSpatialGrid() {
            localDensityState.grid.clear();
            const cellSize = localDensityConfig.cellSize;

            for (let i = 0; i < bubbles.length; i++) {
                const basePosition = bubbles[i].userData.originalPosition;
                const ix = Math.floor(basePosition.x / cellSize);
                const iy = Math.floor(basePosition.y / cellSize);
                const iz = Math.floor(basePosition.z / cellSize);
                const key = getCellKey(ix, iy, iz);

                let cell = localDensityState.grid.get(key);
                if (!cell) {
                    cell = [];
                    localDensityState.grid.set(key, cell);
                }

                cell.push(i);
            }
        }

        function getCellKey(ix, iy, iz) {
            return `${ix},${iy},${iz}`;
        }

        function collectNeighbors(position, radius, excludeIndex, targetArray) {
            targetArray.length = 0;

            const cellSize = localDensityConfig.cellSize;
            const cellRange = Math.ceil(radius / cellSize);
            const radiusSquared = radius * radius;

            const baseX = Math.floor(position.x / cellSize);
            const baseY = Math.floor(position.y / cellSize);
            const baseZ = Math.floor(position.z / cellSize);

            for (let dx = -cellRange; dx <= cellRange; dx++) {
                for (let dy = -cellRange; dy <= cellRange; dy++) {
                    for (let dz = -cellRange; dz <= cellRange; dz++) {
                        const key = getCellKey(baseX + dx, baseY + dy, baseZ + dz);
                        const cell = localDensityState.grid.get(key);

                        if (!cell) continue;

                        for (let i = 0; i < cell.length; i++) {
                            const neighborIndex = cell[i];
                            if (neighborIndex === excludeIndex) continue;

                            const neighborPosition = bubbles[neighborIndex].userData.originalPosition;
                            if (position.distanceToSquared(neighborPosition) <= radiusSquared) {
                                targetArray.push(neighborIndex);
                            }
                        }
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            for (let d = 0; d < dimensions.length; d++) {
                const dimension = dimensions[d];
                const pulse = 0.85 + Math.sin(time * 1.05 + dimension.pulseOffset) * 0.15;

                if (dimension.outline && dimension.outline.material) {
                    dimension.outline.material.opacity = THREE.MathUtils.lerp(0.22, 0.55, pulse);
                }
                if (dimension.fill && dimension.fill.material) {
                    dimension.fill.material.opacity = THREE.MathUtils.lerp(0.03, 0.08, pulse);
                }
                if (dimension.floor && dimension.floor.material) {
                    dimension.floor.material.opacity = THREE.MathUtils.lerp(0.04, 0.12, pulse);
                }
                if (dimension.label && dimension.label.material) {
                    dimension.label.material.opacity = THREE.MathUtils.clamp(0.65 + (pulse - 0.85) * 1.1, 0.45, 1);
                    const baseScale = dimension.labelBaseScale || { x: dimension.label.scale.x, y: dimension.label.scale.y };
                    const scalePulse = 0.96 + Math.sin(time * 2.1 + dimension.pulseOffset) * 0.05;
                    dimension.label.scale.set(baseScale.x * scalePulse, baseScale.y * scalePulse, 1);
                }
            }

            rebuildSpatialGrid();

            for (let i = 0; i < bubbles.length; i++) {
                const bubble = bubbles[i];
                const userData = bubble.userData;
                const basePosition = userData.originalPosition;

                collectNeighbors(basePosition, localDensityConfig.neighborRadius, i, userData.neighborIndices);
                userData.localDensity = userData.neighborIndices.length;

                const pendingForce = userData.pendingForce;
                pendingForce.set(0, 0, 0);

                if (userData.neighborIndices.length > 0) {
                    const accumulator = userData.densityAccumulator;
                    accumulator.set(0, 0, 0);

                    for (let j = 0; j < userData.neighborIndices.length; j++) {
                        const neighborIndex = userData.neighborIndices[j];
                        accumulator.add(bubbles[neighborIndex].userData.originalPosition);
                    }

                    accumulator.divideScalar(userData.neighborIndices.length);
                    accumulator.sub(basePosition);

                    const distance = accumulator.length();
                    if (distance > 0.0001) {
                        const densityFactor = Math.min(userData.neighborIndices.length / localDensityConfig.maxNeighbors, 1);
                        const distanceFactor = Math.min(distance / localDensityConfig.neighborRadius, 1);

                        accumulator.normalize();
                        const strength = localDensityConfig.forceStrength * densityFactor * distanceFactor;
                        pendingForce.copy(accumulator.multiplyScalar(strength));
                    }
                }

                const forceGlow = userData.forceGlow;
                if (forceGlow) {
                    const forceMagnitude = pendingForce.length();
                    const normalizedStrength = Math.min(
                        forceMagnitude / localDensityConfig.forceStrength,
                        1
                    );

                    userData.forceGlowIntensity = normalizedStrength;
                    userData.forceGlowBaseOpacity = normalizedStrength * 0.75;

                    const offset = userData.forceGlowOffset;
                    if (forceMagnitude > 0.0001) {
                        offset.copy(pendingForce).normalize();
                        const offsetDistance = THREE.MathUtils.lerp(
                            userData.baseRadius * userData.sizeCoefficient * 2,
                            localDensityConfig.neighborRadius * 0.4,
                            normalizedStrength
                        );
                        offset.multiplyScalar(offsetDistance);
                    } else {
                        offset.set(0, 0, 0);
                    }

                    const baseScale = userData.forceGlowBaseScale;
                    userData.forceGlowTargetScale = baseScale * (0.6 + normalizedStrength * 0.8);

                    forceGlow.visible = normalizedStrength > 0.02;
                    if (!forceGlow.visible) {
                        forceGlow.material.opacity = 0;
                    } else {
                        forceGlow.material.opacity = THREE.MathUtils.clamp(
                            userData.forceGlowBaseOpacity,
                            0,
                            1
                        );
                    }

                    forceGlow.position.copy(basePosition).add(offset);
                    const appliedScale = userData.forceGlowTargetScale;
                    forceGlow.scale.set(appliedScale, appliedScale, 1);
                }
            }

            for (let i = 0; i < bubbles.length; i++) {
                const bubble = bubbles[i];
                const userData = bubble.userData;

                userData.driftVelocity.multiplyScalar(localDensityConfig.damping);
                userData.driftVelocity.add(userData.pendingForce);

                if (userData.driftVelocity.lengthSq() > localDensityConfig.maxDriftSpeed * localDensityConfig.maxDriftSpeed) {
                    userData.driftVelocity.setLength(localDensityConfig.maxDriftSpeed);
                }

                userData.originalPosition.add(userData.driftVelocity);
                constrainPositionToDimensions(userData);

                const basePosition = userData.originalPosition;

                // –ü–ª–∞–≤–Ω–æ–µ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ
                bubble.position.x = basePosition.x + Math.sin(time * userData.floatSpeed + userData.phase) * 0.5;
                bubble.position.y = basePosition.y + Math.sin(time * userData.floatSpeed * 1.3 + userData.phase) * 1;
                bubble.position.z = basePosition.z + Math.cos(time * userData.floatSpeed * 0.7 + userData.phase) * 0.5;

                // –í—Ä–∞—â–µ–Ω–∏–µ
                bubble.rotation.x += userData.rotationSpeed;
                bubble.rotation.y += userData.rotationSpeed * 0.7;

                // –ü—É–ª—å—Å–∞—Ü–∏—è —É–∑–ª–æ–≤ —Å –º–Ω–æ–≥–∏–º–∏ —Å–≤—è–∑—è–º–∏
                const connectionCount = userData.connections.length;
                let scalePulsation = 1;
                if (connectionCount > 5) {
                    scalePulsation += Math.sin(time * 3 + i) * 0.1 * Math.min(connectionCount / 10, 1);
                }
                bubble.scale.setScalar(userData.sizeCoefficient * scalePulsation);

                const brightnessPulseStrength = 0.5 + Math.min(connectionCount / 10, 1) * 0.5;
                const brightnessPulsation = 1 + Math.sin(time * 2 + userData.phase) * 0.2 * brightnessPulseStrength;
                bubble.material.emissiveIntensity = THREE.MathUtils.clamp(
                    userData.baseBrightness * userData.brightnessCoefficient * brightnessPulsation,
                    0,
                    5
                );

                if (userData.glow) {
                    const glowPulsation = 1 + Math.sin(time * 2.3 + userData.phase) * 0.15 * Math.min(connectionCount / 10, 1);
                    const glowScale = userData.baseGlowScale * userData.sizeCoefficient * glowPulsation;
                    userData.glow.scale.set(glowScale, glowScale, 1);
                    userData.glow.material.opacity = THREE.MathUtils.clamp(
                        userData.baseGlowOpacity * userData.brightnessCoefficient * brightnessPulsation,
                        0,
                        1
                    );
                }

                if (userData.forceGlow) {
                    const forceGlow = userData.forceGlow;
                    const intensity = userData.forceGlowIntensity || 0;
                    const baseOpacity = userData.forceGlowBaseOpacity || 0;
                    const isVisible = intensity > 0.02;
                    forceGlow.visible = isVisible;

                    if (isVisible) {
                        const pulse = 0.85 + Math.sin(time * 3.5 + userData.phase) * 0.15 * (0.5 + intensity * 0.5);
                        forceGlow.material.opacity = THREE.MathUtils.clamp(baseOpacity * pulse, 0, 1);

                        const pulseScale = 0.9 + Math.sin(time * 4.1 + userData.phase * 1.3) * 0.1 * intensity;
                        const targetScale = userData.forceGlowTargetScale * pulseScale;
                        forceGlow.scale.set(targetScale, targetScale, 1);

                        forceGlow.position.copy(basePosition).add(userData.forceGlowOffset);
                    } else {
                        forceGlow.material.opacity = 0;
                    }
                }
            }

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–∏–Ω–∏–π —Å–≤—è–∑–µ–π
            connectionLines.forEach((line) => {
                const userData = line.userData;
                const positions = line.geometry.attributes.position.array;
                
                const from = bubbles[userData.from].position;
                const to = bubbles[userData.to].position;
                
                positions[0] = from.x;
                positions[1] = from.y;
                positions[2] = from.z;
                positions[3] = to.x;
                positions[4] = to.y;
                positions[5] = to.z;
                
                line.geometry.attributes.position.needsUpdate = true;
                
                if (!userData.isGlow) {
                    if (userData.sharedDimension) {
                        if (userData.strength > 0.45) {
                            const pulsation = 0.82 + Math.sin(time * 2 + userData.from) * 0.18;
                            const targetOpacity = userData.strength * 0.6 * pulsation;
                            line.material.opacity = THREE.MathUtils.lerp(line.material.opacity, targetOpacity, 0.2);
                        }
                    } else {
                        const bridgePulse = 0.7 + Math.sin(time * 1.4 + userData.to) * 0.3;
                        const targetOpacity = (0.25 + userData.strength * 0.35) * bridgePulse;
                        line.material.opacity = THREE.MathUtils.lerp(line.material.opacity, targetOpacity, 0.25);
                    }
                }
            });
            
            // –î–≤–∏–∂–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            const speed = isShiftPressed ? 2.0 : 0.8;
            
            velocity.x -= velocity.x * 0.1;
            velocity.y -= velocity.y * 0.1;
            velocity.z -= velocity.z * 0.1;
            
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(yawObject.quaternion);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(yawObject.quaternion);
            right.y = 0;
            right.normalize();
            
            if (moveForward) yawObject.position.add(forward.multiplyScalar(speed));
            if (moveBackward) yawObject.position.add(forward.multiplyScalar(-speed));
            if (moveLeft) yawObject.position.add(right.multiplyScalar(-speed));
            if (moveRight) yawObject.position.add(right.multiplyScalar(speed));
            if (moveUp) yawObject.position.y += speed;
            if (moveDown) yawObject.position.y -= speed;
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
