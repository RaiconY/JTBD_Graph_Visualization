<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jobs To Be Done - 3D Graph</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            cursor: grab;
            background: #0a0a0a;
        }
        
        body:active {
            cursor: grabbing;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            user-select: none;
            z-index: 100;
            pointer-events: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            user-select: none;
            z-index: 100;
            pointer-events: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }
        
        #startButton {
            padding: 15px 40px;
            font-size: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }
        
        #startButton:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .description {
            max-width: 600px;
            text-align: center;
            padding: 0 20px;
            line-height: 1.6;
            opacity: 0.95;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>ü´ß Jobs To Be Done - –ì—Ä–∞—Ñ —Ä–∞–±–æ—Ç ü´ß</h1>
        <div class="description">
            <p>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ JTBD —á–µ—Ä–µ–∑ —Å–≤—è–∑–∞–Ω–Ω—ã–µ –ø—É–∑—ã—Ä–∏</p>
            <p style="font-size: 14px; opacity: 0.8;">600+ —É–∑–ª–æ–≤, —Å–≤—è–∑–∏ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è</p>
        </div>
        <button id="startButton">–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç—å –≥—Ä–∞—Ñ</button>
        <p style="margin-top: 20px; opacity: 0.8; font-size: 14px;">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: WASD - –¥–≤–∏–∂–µ–Ω–∏–µ, –ú—ã—à—å (–∑–∞–∂–∞—Ç—å) - –æ—Å–º–æ—Ç—Ä</p>
    </div>
    
    <div id="info" style="display: none;">
        <div style="font-weight: bold; margin-bottom: 8px;">üìä Jobs To Be Done Graph</div>
        <div style="font-size: 12px; opacity: 0.8;">WASD - –î–≤–∏–∂–µ–Ω–∏–µ</div>
        <div style="font-size: 12px; opacity: 0.8;">–ú—ã—à—å (–∑–∞–∂–∞—Ç—å) - –û—Å–º–æ—Ç—Ä</div>
        <div style="font-size: 12px; opacity: 0.8;">Shift - –£—Å–∫–æ—Ä–µ–Ω–∏–µ</div>
        <div style="font-size: 12px; opacity: 0.8;">Space/Ctrl - –í–≤–µ—Ä—Ö/–í–Ω–∏–∑</div>
    </div>
    
    <div id="stats" style="display: none;">
        <div style="font-weight: bold; margin-bottom: 8px;">üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</div>
        <div id="nodeCount" style="font-size: 12px;">–£–∑–ª–æ–≤: 0</div>
        <div id="connectionCount" style="font-size: 12px;">–°–≤—è–∑–µ–π: 0</div>
        <div id="avgConnections" style="font-size: 12px;">–°—Ä–µ–¥–Ω–µ–µ —Å–≤—è–∑–µ–π: 0</div>
    </div>
    
    <div id="crosshair" style="display: none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let bubbles = [];
        let connections = [];
        let connectionLines = [];
        let bubbleGlowTexture;
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false;
        let isShiftPressed = false;

        const localDensityConfig = {
            cellSize: 60,
            neighborRadius: 80,
            maxNeighbors: 12,
            forceStrength: 0.015,
            damping: 0.9,
            maxDriftSpeed: 0.4
        };

        const localDensityState = {
            grid: new Map()
        };
        
        let velocity = new THREE.Vector3();
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        
        // –ì—Ä—É–ø–ø–∞ –¥–ª—è –∫–∞–º–µ—Ä—ã
        let yawObject;
        let pitchObject;
        
        const startButton = document.getElementById('startButton');
        const startScreen = document.getElementById('startScreen');
        const info = document.getElementById('info');
        const stats = document.getElementById('stats');
        const crosshair = document.getElementById('crosshair');
        
        startButton.addEventListener('click', () => {
            startScreen.style.display = 'none';
            info.style.display = 'block';
            stats.style.display = 'block';
            crosshair.style.display = 'block';
            init();
            animate();
        });
        
        function init() {
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x050510, 100, 800);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –≤—Ä–∞—â–µ–Ω–∏—è
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            yawObject = new THREE.Object3D();
            yawObject.position.set(0, 50, 150);
            
            pitchObject = new THREE.Object3D();
            pitchObject.add(camera);
            
            yawObject.add(pitchObject);
            scene.add(yawObject);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x0a0a0a, 1);
            document.body.appendChild(renderer.domElement);
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(100, 200, 100);
            scene.add(directionalLight);
            
            // –¶–≤–µ—Ç–Ω—ã–µ —Ç–æ—á–µ—á–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞ –¥–ª—è –∞—Ç–º–æ—Å—Ñ–µ—Ä—ã
            const pointLight1 = new THREE.PointLight(0x00ffff, 0.2, 300);
            pointLight1.position.set(-100, 50, -100);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xff00ff, 0.2, 300);
            pointLight2.position.set(100, 50, 100);
            scene.add(pointLight2);
            
            const pointLight3 = new THREE.PointLight(0xffff00, 0.2, 300);
            pointLight3.position.set(0, 100, 0);
            scene.add(pointLight3);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—É–∑—ã—Ä–µ–π –∏ —Å–≤—è–∑–µ–π
            createBubblesAndConnections();
            
            // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–≤—è–∑–µ–π
            createConnectionLines();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            updateStats();
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è –∞—Ç–º–æ—Å—Ñ–µ—Ä—ã
            createParticles();
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        function createBubblesAndConnections() {
            localDensityState.grid.clear();
            const bubbleCount = 600; // –£–≤–µ–ª–∏—á–µ–Ω–æ –≤ 20 —Ä–∞–∑
            const spreadRadius = 250; // –£–≤–µ–ª–∏—á–µ–Ω —Ä–∞–¥–∏—É—Å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è

            if (!bubbleGlowTexture) {
                const glowSize = 256;
                const glowCanvas = document.createElement('canvas');
                glowCanvas.width = glowCanvas.height = glowSize;
                const glowContext = glowCanvas.getContext('2d');

                const center = glowSize / 2;
                const gradient = glowContext.createRadialGradient(center, center, 0, center, center, center);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                glowContext.clearRect(0, 0, glowSize, glowSize);
                glowContext.fillStyle = gradient;
                glowContext.fillRect(0, 0, glowSize, glowSize);

                bubbleGlowTexture = new THREE.CanvasTexture(glowCanvas);
                bubbleGlowTexture.needsUpdate = true;
            }

            // –°–æ–∑–¥–∞–µ–º –ø—É–∑—ã—Ä–∏ —Å –∫–ª–∞—Å—Ç–µ—Ä–Ω—ã–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º
            for (let i = 0; i < bubbleCount; i++) {
                const baseRadius = Math.random() * 0.8 + 0.5; // –ù–µ–º–Ω–æ–≥–æ –º–µ–Ω—å—à–µ —Ä–∞–∑–º–µ—Ä –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
                const geometry = new THREE.SphereGeometry(baseRadius, 16, 8); // –ú–µ–Ω—å—à–µ –ø–æ–ª–∏–≥–æ–Ω–æ–≤ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

                // –¶–≤–µ—Ç–∞ –ø—É–∑—ã—Ä–µ–π
                const hue = (i / bubbleCount) * 0.8 + Math.random() * 0.2;
                const baseBrightness = 0.2;
                const material = new THREE.MeshPhysicalMaterial({
                    color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                    metalness: 0.1,
                    roughness: 0.2,
                    transparent: true,
                    opacity: 0.7,
                    emissive: new THREE.Color().setHSL(hue, 0.7, 0.2),
                    emissiveIntensity: baseBrightness,
                    side: THREE.DoubleSide
                });

                const bubble = new THREE.Mesh(geometry, material);

                const glowMaterial = new THREE.SpriteMaterial({
                    map: bubbleGlowTexture,
                    color: new THREE.Color().setHSL(hue, 0.7, 0.6),
                    transparent: true,
                    opacity: 0.35,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: false
                });
                glowMaterial.needsUpdate = true;
                const glowSprite = new THREE.Sprite(glowMaterial);
                const baseGlowScale = baseRadius * 4;
                glowSprite.scale.set(baseGlowScale, baseGlowScale, 1);
                bubble.add(glowSprite);

                const forceGlowMaterial = new THREE.SpriteMaterial({
                    map: bubbleGlowTexture,
                    color: new THREE.Color().setHSL(hue, 0.85, 0.75),
                    transparent: true,
                    opacity: 0,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: false
                });
                const forceGlowSprite = new THREE.Sprite(forceGlowMaterial);
                const forceGlowBaseScale = baseGlowScale * 0.55;
                forceGlowSprite.scale.set(forceGlowBaseScale, forceGlowBaseScale, 1);
                forceGlowSprite.visible = false;
                scene.add(forceGlowSprite);

                const sizeCoefficient = 0.3 + Math.random() * 1.4;
                const brightnessCoefficient = 0.3 + Math.random() * 1.4;
                const baseGlowOpacity = glowMaterial.opacity;

                bubble.scale.setScalar(sizeCoefficient);
                bubble.material.emissiveIntensity = baseBrightness * brightnessCoefficient;
                glowMaterial.opacity = THREE.MathUtils.clamp(baseGlowOpacity * brightnessCoefficient, 0, 1);

                // –°–æ–∑–¥–∞–µ–º –∫–ª–∞—Å—Ç–µ—Ä–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è –±–æ–ª–µ–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞
                const clusterIndex = Math.floor(Math.random() * 8); // 8 –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
                const clusterAngle = (clusterIndex / 8) * Math.PI * 2;
                const clusterRadius = spreadRadius * (0.3 + Math.random() * 0.7);
                const localSpread = 60; // –†–∞–∑–±—Ä–æ—Å –≤–Ω—É—Ç—Ä–∏ –∫–ª–∞—Å—Ç–µ—Ä–∞
                
                bubble.position.set(
                    Math.cos(clusterAngle) * clusterRadius + (Math.random() - 0.5) * localSpread,
                    (Math.random() - 0.5) * 150,
                    Math.sin(clusterAngle) * clusterRadius + (Math.random() - 0.5) * localSpread
                );
                
                bubble.castShadow = true;
                bubble.receiveShadow = true;

                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
                bubble.userData = {
                    id: i,
                    floatSpeed: Math.random() * 0.002 + 0.001,
                    rotationSpeed: (Math.random() - 0.5) * 0.002,
                    originalPosition: bubble.position.clone(),
                    phase: Math.random() * Math.PI * 2,
                    connections: [],
                    baseRadius: baseRadius,
                    baseBrightness: baseBrightness,
                    sizeCoefficient: sizeCoefficient,
                    brightnessCoefficient: brightnessCoefficient,
                    glow: glowSprite,
                    baseGlowScale: baseGlowScale,
                    baseGlowOpacity: baseGlowOpacity,
                    driftVelocity: new THREE.Vector3(),
                    densityAccumulator: new THREE.Vector3(),
                    pendingForce: new THREE.Vector3(),
                    neighborIndices: [],
                    localDensity: 0,
                    forceGlow: forceGlowSprite,
                    forceGlowBaseScale,
                    forceGlowOffset: new THREE.Vector3(),
                    forceGlowIntensity: 0,
                    forceGlowBaseOpacity: 0,
                    forceGlowTargetScale: forceGlowBaseScale
                };

                forceGlowSprite.position.copy(bubble.position);

                scene.add(bubble);
                bubbles.push(bubble);
            }
            
            // –°–æ–∑–¥–∞–µ–º —Å–≤—è–∑–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
            const maxConnectionDistance = 50; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è —Å–≤—è–∑–∏
            const minConnectionDistance = 5; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
            
            for (let i = 0; i < bubbles.length; i++) {
                for (let j = i + 1; j < bubbles.length; j++) {
                    const distance = bubbles[i].position.distanceTo(bubbles[j].position);
                    
                    // –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Å–≤—è–∑–∏ –æ–±—Ä–∞—Ç–Ω–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
                    if (distance < maxConnectionDistance && distance > minConnectionDistance) {
                        // –ü–ª–∞–≤–∞—é—â–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –æ—Ç 0.9 (–±–ª–∏–∑–∫–æ) –¥–æ 0.05 (–¥–∞–ª–µ–∫–æ)
                        const probability = Math.pow(1 - (distance / maxConnectionDistance), 2);
                        
                        if (Math.random() < probability) {
                            // –°–∏–ª–∞ —Å–≤—è–∑–∏ –æ–±—Ä–∞—Ç–Ω–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
                            const strength = 1 - (distance / maxConnectionDistance);
                            
                            connections.push({
                                from: i,
                                to: j,
                                distance: distance,
                                strength: strength
                            });
                            
                            bubbles[i].userData.connections.push(j);
                            bubbles[j].userData.connections.push(i);
                        }
                    }
                }
            }
        }
        
        function createConnectionLines() {
            // –ì—Ä—É–ø–ø–∞ –¥–ª—è –≤—Å–µ—Ö –ª–∏–Ω–∏–π
            const linesGroup = new THREE.Group();
            
            connections.forEach(connection => {
                const points = [];
                points.push(bubbles[connection.from].position);
                points.push(bubbles[connection.to].position);
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // –ú–∞—Ç–µ—Ä–∏–∞–ª —Å —Ç–æ–ª—â–∏–Ω–æ–π –∏ —Å–≤–µ—á–µ–Ω–∏–µ–º –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∏–ª—ã —Å–≤—è–∑–∏
                const material = new THREE.LineBasicMaterial({
                    color: new THREE.Color().setHSL(0.5 - connection.strength * 0.3, 0.8, 0.5 + connection.strength * 0.3),
                    opacity: connection.strength * 0.6 + 0.1,
                    transparent: true,
                    linewidth: connection.strength * 3 + 1, // –¢–æ–ª—â–∏–Ω–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å–∏–ª—ã
                    blending: THREE.AdditiveBlending
                });
                
                const line = new THREE.Line(geometry, material);
                
                // –î–ª—è –æ—á–µ–Ω—å —Å–∏–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π –¥–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—á–µ–Ω–∏–µ
                if (connection.strength > 0.7) {
                    const glowMaterial = new THREE.LineBasicMaterial({
                        color: new THREE.Color().setHSL(0.5 - connection.strength * 0.3, 1, 0.7),
                        opacity: connection.strength * 0.2,
                        transparent: true,
                        linewidth: connection.strength * 6 + 2,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const glowLine = new THREE.Line(geometry.clone(), glowMaterial);
                    glowLine.userData = {
                        from: connection.from,
                        to: connection.to,
                        strength: connection.strength,
                        isGlow: true
                    };
                    
                    linesGroup.add(glowLine);
                    connectionLines.push(glowLine);
                }
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏
                line.userData = {
                    from: connection.from,
                    to: connection.to,
                    strength: connection.strength,
                    distance: connection.distance
                };
                
                linesGroup.add(line);
                connectionLines.push(line);
            });
            
            scene.add(linesGroup);
        }
        
        function createParticles() {
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = 2000;
            const positions = new Float32Array(particlesCount * 3);
            const colors = new Float32Array(particlesCount * 3);
            
            for (let i = 0; i < particlesCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 600;
                positions[i + 1] = (Math.random() - 0.5) * 400;
                positions[i + 2] = (Math.random() - 0.5) * 600;
                
                const color = new THREE.Color().setHSL(Math.random(), 0.3, 0.3);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({ 
                size: 0.2,
                opacity: 0.4,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);
        }
        
        function updateStats() {
            document.getElementById('nodeCount').textContent = `–£–∑–ª–æ–≤: ${bubbles.length}`;
            document.getElementById('connectionCount').textContent = `–°–≤—è–∑–µ–π: ${connections.length}`;
            
            let totalConnections = 0;
            bubbles.forEach(bubble => {
                totalConnections += bubble.userData.connections.length;
            });
            const avgConnections = (totalConnections / bubbles.length).toFixed(1);
            document.getElementById('avgConnections').textContent = `–°—Ä–µ–¥–Ω–µ–µ —Å–≤—è–∑–µ–π: ${avgConnections}`;
        }
        
        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseUp(event) {
            isMouseDown = false;
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            yawObject.rotation.y -= deltaX * 0.002;
            pitchObject.rotation.x -= deltaY * 0.002;
            
            pitchObject.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitchObject.rotation.x));
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onKeyDown(event) {
            switch(event.key.toLowerCase()) {
                case 'w':
                case '—Ü':
                    moveForward = true;
                    break;
                case 's':
                case '—ã':
                    moveBackward = true;
                    break;
                case 'a':
                case '—Ñ':
                    moveLeft = true;
                    break;
                case 'd':
                case '–≤':
                    moveRight = true;
                    break;
                case ' ':
                    moveUp = true;
                    event.preventDefault();
                    break;
                case 'control':
                    moveDown = true;
                    event.preventDefault();
                    break;
                case 'shift':
                    isShiftPressed = true;
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch(event.key.toLowerCase()) {
                case 'w':
                case '—Ü':
                    moveForward = false;
                    break;
                case 's':
                case '—ã':
                    moveBackward = false;
                    break;
                case 'a':
                case '—Ñ':
                    moveLeft = false;
                    break;
                case 'd':
                case '–≤':
                    moveRight = false;
                    break;
                case ' ':
                    moveUp = false;
                    break;
                case 'control':
                    moveDown = false;
                    break;
                case 'shift':
                    isShiftPressed = false;
                    break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function rebuildSpatialGrid() {
            localDensityState.grid.clear();
            const cellSize = localDensityConfig.cellSize;

            for (let i = 0; i < bubbles.length; i++) {
                const basePosition = bubbles[i].userData.originalPosition;
                const ix = Math.floor(basePosition.x / cellSize);
                const iy = Math.floor(basePosition.y / cellSize);
                const iz = Math.floor(basePosition.z / cellSize);
                const key = getCellKey(ix, iy, iz);

                let cell = localDensityState.grid.get(key);
                if (!cell) {
                    cell = [];
                    localDensityState.grid.set(key, cell);
                }

                cell.push(i);
            }
        }

        function getCellKey(ix, iy, iz) {
            return `${ix},${iy},${iz}`;
        }

        function collectNeighbors(position, radius, excludeIndex, targetArray) {
            targetArray.length = 0;

            const cellSize = localDensityConfig.cellSize;
            const cellRange = Math.ceil(radius / cellSize);
            const radiusSquared = radius * radius;

            const baseX = Math.floor(position.x / cellSize);
            const baseY = Math.floor(position.y / cellSize);
            const baseZ = Math.floor(position.z / cellSize);

            for (let dx = -cellRange; dx <= cellRange; dx++) {
                for (let dy = -cellRange; dy <= cellRange; dy++) {
                    for (let dz = -cellRange; dz <= cellRange; dz++) {
                        const key = getCellKey(baseX + dx, baseY + dy, baseZ + dz);
                        const cell = localDensityState.grid.get(key);

                        if (!cell) continue;

                        for (let i = 0; i < cell.length; i++) {
                            const neighborIndex = cell[i];
                            if (neighborIndex === excludeIndex) continue;

                            const neighborPosition = bubbles[neighborIndex].userData.originalPosition;
                            if (position.distanceToSquared(neighborPosition) <= radiusSquared) {
                                targetArray.push(neighborIndex);
                            }
                        }
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            rebuildSpatialGrid();

            for (let i = 0; i < bubbles.length; i++) {
                const bubble = bubbles[i];
                const userData = bubble.userData;
                const basePosition = userData.originalPosition;

                collectNeighbors(basePosition, localDensityConfig.neighborRadius, i, userData.neighborIndices);
                userData.localDensity = userData.neighborIndices.length;

                const pendingForce = userData.pendingForce;
                pendingForce.set(0, 0, 0);

                if (userData.neighborIndices.length > 0) {
                    const accumulator = userData.densityAccumulator;
                    accumulator.set(0, 0, 0);

                    for (let j = 0; j < userData.neighborIndices.length; j++) {
                        const neighborIndex = userData.neighborIndices[j];
                        accumulator.add(bubbles[neighborIndex].userData.originalPosition);
                    }

                    accumulator.divideScalar(userData.neighborIndices.length);
                    accumulator.sub(basePosition);

                    const distance = accumulator.length();
                    if (distance > 0.0001) {
                        const densityFactor = Math.min(userData.neighborIndices.length / localDensityConfig.maxNeighbors, 1);
                        const distanceFactor = Math.min(distance / localDensityConfig.neighborRadius, 1);

                        accumulator.normalize();
                        const strength = localDensityConfig.forceStrength * densityFactor * distanceFactor;
                        pendingForce.copy(accumulator.multiplyScalar(strength));
                    }
                }

                const forceGlow = userData.forceGlow;
                if (forceGlow) {
                    const forceMagnitude = pendingForce.length();
                    const normalizedStrength = Math.min(
                        forceMagnitude / localDensityConfig.forceStrength,
                        1
                    );

                    userData.forceGlowIntensity = normalizedStrength;
                    userData.forceGlowBaseOpacity = normalizedStrength * 0.75;

                    const offset = userData.forceGlowOffset;
                    if (forceMagnitude > 0.0001) {
                        offset.copy(pendingForce).normalize();
                        const offsetDistance = THREE.MathUtils.lerp(
                            userData.baseRadius * userData.sizeCoefficient * 2,
                            localDensityConfig.neighborRadius * 0.4,
                            normalizedStrength
                        );
                        offset.multiplyScalar(offsetDistance);
                    } else {
                        offset.set(0, 0, 0);
                    }

                    const baseScale = userData.forceGlowBaseScale;
                    userData.forceGlowTargetScale = baseScale * (0.6 + normalizedStrength * 0.8);

                    forceGlow.visible = normalizedStrength > 0.02;
                    if (!forceGlow.visible) {
                        forceGlow.material.opacity = 0;
                    } else {
                        forceGlow.material.opacity = THREE.MathUtils.clamp(
                            userData.forceGlowBaseOpacity,
                            0,
                            1
                        );
                    }

                    forceGlow.position.copy(basePosition).add(offset);
                    const appliedScale = userData.forceGlowTargetScale;
                    forceGlow.scale.set(appliedScale, appliedScale, 1);
                }
            }

            for (let i = 0; i < bubbles.length; i++) {
                const bubble = bubbles[i];
                const userData = bubble.userData;

                userData.driftVelocity.multiplyScalar(localDensityConfig.damping);
                userData.driftVelocity.add(userData.pendingForce);

                if (userData.driftVelocity.lengthSq() > localDensityConfig.maxDriftSpeed * localDensityConfig.maxDriftSpeed) {
                    userData.driftVelocity.setLength(localDensityConfig.maxDriftSpeed);
                }

                userData.originalPosition.add(userData.driftVelocity);

                const basePosition = userData.originalPosition;

                // –ü–ª–∞–≤–Ω–æ–µ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ
                bubble.position.x = basePosition.x + Math.sin(time * userData.floatSpeed + userData.phase) * 0.5;
                bubble.position.y = basePosition.y + Math.sin(time * userData.floatSpeed * 1.3 + userData.phase) * 1;
                bubble.position.z = basePosition.z + Math.cos(time * userData.floatSpeed * 0.7 + userData.phase) * 0.5;

                // –í—Ä–∞—â–µ–Ω–∏–µ
                bubble.rotation.x += userData.rotationSpeed;
                bubble.rotation.y += userData.rotationSpeed * 0.7;

                // –ü—É–ª—å—Å–∞—Ü–∏—è —É–∑–ª–æ–≤ —Å –º–Ω–æ–≥–∏–º–∏ —Å–≤—è–∑—è–º–∏
                const connectionCount = userData.connections.length;
                let scalePulsation = 1;
                if (connectionCount > 5) {
                    scalePulsation += Math.sin(time * 3 + i) * 0.1 * Math.min(connectionCount / 10, 1);
                }
                bubble.scale.setScalar(userData.sizeCoefficient * scalePulsation);

                const brightnessPulseStrength = 0.5 + Math.min(connectionCount / 10, 1) * 0.5;
                const brightnessPulsation = 1 + Math.sin(time * 2 + userData.phase) * 0.2 * brightnessPulseStrength;
                bubble.material.emissiveIntensity = THREE.MathUtils.clamp(
                    userData.baseBrightness * userData.brightnessCoefficient * brightnessPulsation,
                    0,
                    5
                );

                if (userData.glow) {
                    const glowPulsation = 1 + Math.sin(time * 2.3 + userData.phase) * 0.15 * Math.min(connectionCount / 10, 1);
                    const glowScale = userData.baseGlowScale * userData.sizeCoefficient * glowPulsation;
                    userData.glow.scale.set(glowScale, glowScale, 1);
                    userData.glow.material.opacity = THREE.MathUtils.clamp(
                        userData.baseGlowOpacity * userData.brightnessCoefficient * brightnessPulsation,
                        0,
                        1
                    );
                }

                if (userData.forceGlow) {
                    const forceGlow = userData.forceGlow;
                    const intensity = userData.forceGlowIntensity || 0;
                    const baseOpacity = userData.forceGlowBaseOpacity || 0;
                    const isVisible = intensity > 0.02;
                    forceGlow.visible = isVisible;

                    if (isVisible) {
                        const pulse = 0.85 + Math.sin(time * 3.5 + userData.phase) * 0.15 * (0.5 + intensity * 0.5);
                        forceGlow.material.opacity = THREE.MathUtils.clamp(baseOpacity * pulse, 0, 1);

                        const pulseScale = 0.9 + Math.sin(time * 4.1 + userData.phase * 1.3) * 0.1 * intensity;
                        const targetScale = userData.forceGlowTargetScale * pulseScale;
                        forceGlow.scale.set(targetScale, targetScale, 1);

                        forceGlow.position.copy(basePosition).add(userData.forceGlowOffset);
                    } else {
                        forceGlow.material.opacity = 0;
                    }
                }
            }

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–∏–Ω–∏–π —Å–≤—è–∑–µ–π
            connectionLines.forEach((line) => {
                const userData = line.userData;
                const positions = line.geometry.attributes.position.array;
                
                const from = bubbles[userData.from].position;
                const to = bubbles[userData.to].position;
                
                positions[0] = from.x;
                positions[1] = from.y;
                positions[2] = from.z;
                positions[3] = to.x;
                positions[4] = to.y;
                positions[5] = to.z;
                
                line.geometry.attributes.position.needsUpdate = true;
                
                // –ü—É–ª—å—Å–∞—Ü–∏—è —è—Ä–∫–æ—Å—Ç–∏ –¥–ª—è —Å–∏–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π
                if (userData.strength > 0.5 && !userData.isGlow) {
                    const pulsation = 0.8 + Math.sin(time * 2 + userData.from) * 0.2;
                    line.material.opacity = userData.strength * 0.6 * pulsation;
                }
            });
            
            // –î–≤–∏–∂–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            const speed = isShiftPressed ? 2.0 : 0.8;
            
            velocity.x -= velocity.x * 0.1;
            velocity.y -= velocity.y * 0.1;
            velocity.z -= velocity.z * 0.1;
            
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(yawObject.quaternion);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(yawObject.quaternion);
            right.y = 0;
            right.normalize();
            
            if (moveForward) yawObject.position.add(forward.multiplyScalar(speed));
            if (moveBackward) yawObject.position.add(forward.multiplyScalar(-speed));
            if (moveLeft) yawObject.position.add(right.multiplyScalar(-speed));
            if (moveRight) yawObject.position.add(right.multiplyScalar(speed));
            if (moveUp) yawObject.position.y += speed;
            if (moveDown) yawObject.position.y -= speed;
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
